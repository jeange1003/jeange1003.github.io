<html>

<head>
  <title>Web Component -- Shadow DOM</title>
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
  <link rel="stylesheet" href="common.css" />
  <script src="utils.js"></script>
  <style>
    .paging {
      justify-content: flex-end;
    }
  </style>
</head>

<body>
  <h1>Web Component -- Shadow DOM</h1>
  <p>Web Component内部可以增加子元素，这和原生元素是一样的。除此以外，为了达到封装内部逻辑的效果，也就是Component的效果，Web Component还支持Shadow DOM</p>
  <p>例子：</p>
  <pre id="code1">

  </pre>
  <pre>
class EncapsulatedComponent extends HTMLElement {
  constructor() {
    super()
    this.shadow = this.attachShadow({ mode: 'open' })
    const div = document.createElement('div')
    div.id = 'rect'
    this.shadow.appendChild(div)
    const style = document.createElement('style')
    style.textContent = `
      #rect {
        background-color: red;
        width: 100px;
        height: 100px;
      }
    `
    this.shadow.appendChild(style)
  }
}

customElements.define('encapsulated-component', EncapsulatedComponent)
  </pre>
  <div id="demo1">
    <div id="rect"></div>
    <style>
      #rect {
        border: 5px solid green;
        width: 150px;
        height: 150px;
        background-color: lightgreen;
      }
    </style>
    <encapsulated-component></encapsulated-component>
  </div>
  <script>outputHtml({ domId: 'demo1', loggerId: 'code1' })</script>
  <p>组件内有一个id=rect的div，组件外部也有同id的div，但两者的样式没有相互影响</p>
  <div class="paging">
    <a href="page2.html">下一页</a>
  </div>

  <script src="./page2.js"></script>

</body>

</html>